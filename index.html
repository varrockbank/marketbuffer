<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Marketbuffer</title>
  <script src="vendor/buffer.js"></script>
  <link rel="stylesheet" href="vendor/buffer.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Chicago&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Chicago', 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      background: #a8a8a8;
      min-height: 100vh;
      cursor: default;
      user-select: none;
    }

    /* Menu Bar */
    .menu-bar {
      background: #fff;
      border-bottom: 2px solid #000;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 8px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
    }

    .menu-bar-left {
      display: flex;
      align-items: center;
    }

    .menu-bar-right {
      display: flex;
      align-items: center;
    }

    .menu-item {
      padding: 2px 12px;
      cursor: pointer;
    }

    .menu-item-bold {
      font-weight: bold;
    }

    .menu-item:hover {
      background: #000;
      color: #fff;
    }

    .menu-item-container {
      position: relative;
    }

    .menu-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: #fff;
      border: 1px solid #000;
      box-shadow: 2px 2px 0 #000;
      min-width: 180px;
      z-index: 1001;
    }

    .menu-dropdown.open {
      display: block;
    }

    .menu-dropdown-item {
      padding: 4px 12px 4px 24px;
      cursor: pointer;
      position: relative;
      white-space: nowrap;
    }

    .menu-dropdown-item:hover {
      background: #000;
      color: #fff;
    }

    .menu-dropdown-item.checked::before {
      content: 'âœ“';
      position: absolute;
      left: 8px;
    }

    /* Primary Sidebar */
    .primary-sidebar {
      width: 200px;
      background: #fff;
      border-right: 2px solid #000;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-section {
      border-bottom: 1px solid #000;
    }

    .sidebar-section-header {
      padding: 8px 12px;
      font-weight: bold;
      font-size: 11px;
      background: #e0e0e0;
      border-bottom: 1px solid #000;
    }

    .sidebar-item {
      padding: 6px 12px 6px 24px;
      font-size: 11px;
      cursor: pointer;
      position: relative;
    }

    .sidebar-item:hover {
      background: #000;
      color: #fff;
    }

    .sidebar-item.active {
      background: #c0c0c0;
    }

    .sidebar-item-icon {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
    }

    .sidebar-spacer {
      flex: 1;
    }

    /* File Tree */
    .file-tree {
      flex: 1;
      overflow-y: auto;
      padding: 4px 0;
    }

    .tree-item {
      cursor: pointer;
      white-space: nowrap;
    }

    .tree-item-row {
      display: flex;
      align-items: center;
      padding: 3px 8px;
      font-size: 11px;
    }

    .tree-item-row:hover {
      background: #000;
      color: #fff;
    }

    .tree-item-row.selected {
      background: #c0c0c0;
    }

    .tree-toggle {
      width: 12px;
      height: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      flex-shrink: 0;
      margin-right: 2px;
    }

    .tree-icon {
      width: 14px;
      height: 14px;
      margin-right: 4px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
    }

    .tree-label {
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .tree-children {
      display: none;
    }

    .tree-children.expanded {
      display: block;
    }

    .tree-item[data-depth="0"] > .tree-item-row { padding-left: 8px; }
    .tree-item[data-depth="1"] > .tree-item-row { padding-left: 22px; }
    .tree-item[data-depth="2"] > .tree-item-row { padding-left: 36px; }
    .tree-item[data-depth="3"] > .tree-item-row { padding-left: 50px; }
    .tree-item[data-depth="4"] > .tree-item-row { padding-left: 64px; }

    .sidebar-footer {
      padding: 8px 12px;
      font-size: 10px;
      color: #666;
      border-top: 1px solid #000;
      background: #e0e0e0;
    }

    /* Main Layout Container */
    .main-layout {
      display: flex;
      position: fixed;
      top: 20px;
      left: 0;
      right: 0;
      bottom: 0;
    }

    /* Desktop */
    .desktop {
      flex: 1;
      position: relative;
      background:
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 1px,
          #a8a8a8 1px,
          #a8a8a8 2px
        ),
        repeating-linear-gradient(
          90deg,
          transparent,
          transparent 1px,
          #a8a8a8 1px,
          #a8a8a8 2px
        );
      background-color: #a8a8a8;
      overflow: hidden;
    }

    /* Desktop Icons */
    .desktop-icons {
      position: absolute;
      top: 30px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .desktop-icon {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 64px;
      cursor: pointer;
    }

    .desktop-icon:hover .icon-label {
      background: #000;
      color: #fff;
    }

    .icon-image {
      width: 32px;
      height: 32px;
      background: #fff;
      border: 1px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 4px;
    }

    .icon-label {
      font-size: 10px;
      text-align: center;
      padding: 1px 3px;
    }

    /* Window */
    .window {
      position: absolute;
      background: #fff;
      border: 2px solid #000;
      box-shadow: 2px 2px 0 #000;
      min-width: 300px;
      left: auto;
    }

    .window-title-bar {
      background: #fff;
      border-bottom: 2px solid #000;
      padding: 2px 4px;
      display: flex;
      align-items: center;
      height: 20px;
    }

    .window-draggable .window-title-bar {
      cursor: move;
    }

    .window-title-bar::before,
    .window-title-bar::after {
      content: '';
      flex: 1;
      height: 10px;
      background: repeating-linear-gradient(
        0deg,
        #000,
        #000 1px,
        #fff 1px,
        #fff 3px
      );
    }

    .window-title {
      padding: 0 8px;
      font-weight: bold;
      font-size: 12px;
      white-space: nowrap;
    }

    .close-box {
      width: 12px;
      height: 12px;
      border: 1px solid #000;
      background: #fff;
      margin-right: 4px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .close-box:hover {
      background: #000;
    }

    .window-content {
      padding: 16px;
      background: #fff;
    }

    /* Scrollbar styling for window */
    .window-scrollable {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #000;
      margin: 8px;
      background: #fff;
    }

    .window-scrollable::-webkit-scrollbar {
      width: 16px;
    }

    .window-scrollable::-webkit-scrollbar-track {
      background:
        repeating-linear-gradient(
          45deg,
          #fff,
          #fff 2px,
          #a8a8a8 2px,
          #a8a8a8 4px
        );
      border-left: 1px solid #000;
    }

    .window-scrollable::-webkit-scrollbar-thumb {
      background: #fff;
      border: 1px solid #000;
    }

    /* Finder Window */
    .finder-window {
      top: 60px;
      left: 40px;
      width: 400px;
    }

    .finder-content {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 16px;
      padding: 16px;
    }

    .finder-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
    }

    .finder-item:hover .finder-label {
      background: #000;
      color: #fff;
    }

    .folder-icon {
      width: 32px;
      height: 26px;
      background: #fff;
      border: 1px solid #000;
      position: relative;
      margin-bottom: 4px;
    }

    .folder-icon::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 2px;
      width: 14px;
      height: 6px;
      background: #fff;
      border: 1px solid #000;
      border-bottom: none;
    }

    .document-icon {
      width: 24px;
      height: 32px;
      background: #fff;
      border: 1px solid #000;
      position: relative;
      margin-bottom: 4px;
    }

    .document-icon::before {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 8px;
      height: 8px;
      background: #fff;
      border-left: 1px solid #000;
      border-bottom: 1px solid #000;
    }

    .finder-label {
      font-size: 10px;
      text-align: center;
      padding: 1px 3px;
    }

    /* About Window */
    .about-window {
      top: 120px;
      left: 120px;
      width: 340px;
    }

    .about-content {
      text-align: center;
      padding: 24px;
    }

    .macket-icon {
      width: 64px;
      height: 80px;
      margin: 0 auto 16px;
      border: 2px solid #000;
      background: #fff;
      position: relative;
    }

    .macket-screen {
      width: 48px;
      height: 36px;
      border: 2px solid #000;
      margin: 8px auto 4px;
      background: #a8a8a8;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .macket-screen::before {
      content: ':-)';
      font-size: 10px;
    }

    .macket-base {
      width: 56px;
      height: 8px;
      background: #fff;
      border-top: 2px solid #000;
      margin: 0 auto;
    }

    .about-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 8px;
    }

    .about-text {
      font-size: 11px;
      line-height: 1.6;
      margin-bottom: 8px;
    }

    .about-divider {
      border: none;
      border-top: 1px solid #000;
      margin: 12px 0;
    }

    /* Button */
    .macket-button {
      background: #fff;
      border: 2px solid #000;
      border-radius: 8px;
      padding: 4px 16px;
      font-family: inherit;
      font-size: 12px;
      cursor: pointer;
      box-shadow: 2px 2px 0 #000;
    }

    .macket-button:active {
      background: #000;
      color: #fff;
      box-shadow: none;
      transform: translate(2px, 2px);
    }

    /* Trash Icon */
    .trash-icon {
      width: 28px;
      height: 32px;
      background: #fff;
      border: 1px solid #000;
      position: relative;
    }

    .trash-icon::before {
      content: '';
      position: absolute;
      top: -4px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 4px;
      background: #fff;
      border: 1px solid #000;
    }

    .trash-icon::after {
      content: '';
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 16px;
      height: 18px;
      border-left: 1px solid #000;
      border-right: 1px solid #000;
      background: repeating-linear-gradient(
        90deg,
        transparent,
        transparent 4px,
        #000 4px,
        #000 5px
      );
    }

    /* Floppy disk icon */
    .floppy-icon {
      width: 30px;
      height: 32px;
      background: #fff;
      border: 1px solid #000;
      position: relative;
    }

    .floppy-icon::before {
      content: '';
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 18px;
      height: 10px;
      background: #a8a8a8;
      border: 1px solid #000;
    }

    .floppy-icon::after {
      content: '';
      position: absolute;
      bottom: 2px;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 12px;
      background: #fff;
      border: 1px solid #000;
    }

    /* HyperCard */
    .hypercard-content {
      padding: 0;
      background: #fff;
    }

    .hypercard-card {
      padding: 16px;
      min-height: 200px;
      border-bottom: 2px solid #000;
    }

    .hypercard-title {
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 16px;
      text-decoration: underline;
    }

    .hypercard-text {
      font-size: 12px;
      line-height: 1.6;
      margin-bottom: 12px;
    }

    .hypercard-button {
      background: #fff;
      border: 2px solid #000;
      border-radius: 6px;
      padding: 6px 16px;
      font-family: inherit;
      font-size: 12px;
      cursor: pointer;
      margin: 4px;
      box-shadow: 1px 1px 0 #000;
    }

    .hypercard-button:active {
      background: #000;
      color: #fff;
    }

    .hypercard-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px;
      background: #e0e0e0;
      border-top: 1px solid #000;
    }

    .hypercard-nav-btn {
      background: #fff;
      border: 1px solid #000;
      padding: 4px 12px;
      font-family: inherit;
      font-size: 11px;
      cursor: pointer;
    }

    .hypercard-nav-btn:hover {
      background: #000;
      color: #fff;
    }

    .hypercard-page {
      font-size: 10px;
    }

    /* Tabbed Window */
    .tabbed-window {
      position: absolute;
      background: #fff;
      border: 1px solid #000;
      padding: 5px;
      display: flex;
      flex-direction: column;
    }

    .tabbed-window-inner {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #fff;
    }

    .tabbed-window-tabs {
      display: flex;
      background: #c0c0c0;
      border: 2px solid #000;
      min-height: 24px;
    }

    .tabbed-window-tab {
      padding: 4px 16px;
      background: #e0e0e0;
      border-right: 1px solid #000;
      font-size: 11px;
      cursor: pointer;
      position: relative;
      padding-left: 20px;
    }

    .tabbed-window-tab:hover {
      background: #fff;
    }

    .tabbed-window-tab.active {
      background: #fff;
      border-bottom: 2px solid #fff;
      margin-bottom: -2px;
    }

    .tab-close {
      display: none;
      position: absolute;
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 10px;
      line-height: 1;
      cursor: pointer;
    }

    .tabbed-window-tab:hover .tab-close {
      display: block;
    }

    .tab-close:hover {
      font-weight: bold;
    }

    .tabbed-window-tab-add {
      padding: 4px 12px;
      background: #e0e0e0;
      border-right: 1px solid #000;
      font-size: 11px;
      cursor: pointer;
    }

    .tabbed-window-tab-add:hover {
      background: #fff;
    }

    .tabbed-close-box {
      margin: 4px 8px 4px 8px;
      align-self: center;
    }

    .first-tab-with-close {
      border-left: 1px solid #000;
    }

    .tabbed-window-content {
      flex: 1;
      background: #fff;
      overflow: hidden;
      display: flex;
      position: relative;
    }

    .tab-pane-container {
      display: none;
      flex: 1;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }

    .tab-pane-container.active {
      display: flex;
    }

    /* Panes */
    .pane {
      flex: 1;
      display: flex;
      background: #fff;
      overflow: auto;
      cursor: pointer;
    }

    .pane-multi {
      margin: 2px;
      border: 1px solid #000;
      position: relative;
      overflow: visible;
    }

    .pane-split-vertical > .pane-multi,
    .pane-split-vertical > .pane-split {
      margin-top: 8px;
    }

    .pane-split-vertical > .pane-multi:first-child,
    .pane-split-vertical > .pane-split:first-child {
      margin-top: 0;
    }

    .tab-pane-container > .pane-split {
      padding-top: 8px;
    }

    .pane-multi.focused {
      border: 2px solid teal;
    }

    .pane-split.parent-highlight {
      background: rgba(0, 128, 128, 0.1);
    }

    .pane-multi.closing-highlight {
      background: rgba(255, 0, 0, 0.2);
    }

    .pane-multi.sibling-highlight {
      background: rgba(0, 128, 128, 0.2);
    }

    .pane-title {
      position: absolute;
      top: -8px;
      left: 8px;
      background: #fff;
      padding: 0 4px;
      font-size: 10px;
      font-weight: bold;
      line-height: 1;
    }

    .pane-content {
      flex: 1;
      padding: 8px;
      overflow: auto;
    }

    .pane-multi .pane-content {
      padding-top: 12px;
    }

    .pane-split {
      flex: 1;
      display: flex;
    }

    .pane-split-vertical {
      flex-direction: column;
    }

    .pane-split-horizontal {
      flex-direction: row;
    }

    /* Upgrade Alert Modal */
    .alert-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .alert-box {
      background: #fff;
      border: 2px solid #000;
      box-shadow: 4px 4px 0 #000;
      padding: 24px;
      max-width: 320px;
      text-align: center;
    }

    .alert-title {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 12px;
    }

    .alert-message {
      font-size: 12px;
      line-height: 1.5;
      margin-bottom: 20px;
    }

    .alert-buttons {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .alert-btn {
      padding: 6px 16px;
      font-family: inherit;
      font-size: 12px;
      cursor: pointer;
      border: 2px solid #000;
      background: #fff;
    }

    .alert-btn:hover {
      background: #e0e0e0;
    }

    .alert-btn-upgrade {
      background: teal;
      color: #fff;
      border-color: teal;
    }

    .alert-btn-upgrade:hover {
      background: #006666;
    }
  </style>
</head>
<body>
  <!-- Menu Bar -->
  <div class="menu-bar">
    <div class="menu-bar-left">
      <div class="menu-item-container">
        <span class="menu-item menu-item-bold" id="active-window-menu"></span>
        <div class="menu-dropdown" id="active-window-dropdown"></div>
      </div>
    </div>
    <div class="menu-bar-right">
      <div class="menu-item-container">
        <span class="menu-item" id="applications-menu">Applications</span>
        <div class="menu-dropdown" id="applications-dropdown"></div>
      </div>
      <span class="menu-item">Help</span>
      <span class="menu-item">Settings</span>
      <span class="menu-item">Logout</span>
    </div>
  </div>

  <!-- Main Layout -->
  <div class="main-layout">
    <!-- Primary Sidebar -->
    <div class="primary-sidebar" id="primary-sidebar">
      <div class="sidebar-section">
        <div class="sidebar-section-header">Workspace</div>
        <div class="sidebar-item active">
          <span class="sidebar-item-icon">&#9642;</span>
          Project Files
        </div>
        <div class="sidebar-item">
          <span class="sidebar-item-icon">&#9642;</span>
          Search
        </div>
        <div class="sidebar-item">
          <span class="sidebar-item-icon">&#9642;</span>
          Source Control
        </div>
      </div>
      <div class="sidebar-section">
        <div class="sidebar-section-header">Favorites</div>
        <div class="sidebar-item">
          <span class="sidebar-item-icon">&#9734;</span>
          index.html
        </div>
        <div class="sidebar-item">
          <span class="sidebar-item-icon">&#9734;</span>
          styles.css
        </div>
      </div>
      <div class="sidebar-section sidebar-section-files">
        <div class="sidebar-section-header">Files</div>
      </div>
      <div class="file-tree" id="file-tree">
        <!-- File tree rendered by JavaScript -->
      </div>
      <div class="sidebar-footer">
        Marketbuffer v1.0
      </div>
    </div>

    <!-- Desktop -->
    <div class="desktop" id="desktop">
      <!-- Windows are rendered dynamically -->
    </div>
  </div>

  <script>
    // File tree data structure
    const fileTreeData = {
      name: 'marketbuffer',
      type: 'folder',
      expanded: true,
      children: [
        {
          name: 'src',
          type: 'folder',
          expanded: true,
          children: [
            {
              name: 'components',
              type: 'folder',
              expanded: false,
              children: [
                { name: 'Button.js', type: 'file' },
                { name: 'Modal.js', type: 'file' },
                { name: 'Sidebar.js', type: 'file' }
              ]
            },
            {
              name: 'utils',
              type: 'folder',
              expanded: false,
              children: [
                { name: 'helpers.js', type: 'file' },
                { name: 'constants.js', type: 'file' }
              ]
            },
            { name: 'index.js', type: 'file' },
            { name: 'App.js', type: 'file' }
          ]
        },
        {
          name: 'public',
          type: 'folder',
          expanded: false,
          children: [
            { name: 'index.html', type: 'file' },
            { name: 'favicon.ico', type: 'file' }
          ]
        },
        {
          name: 'styles',
          type: 'folder',
          expanded: false,
          children: [
            { name: 'main.css', type: 'file' },
            { name: 'variables.css', type: 'file' }
          ]
        },
        { name: 'package.json', type: 'file' },
        { name: 'README.md', type: 'file' },
        { name: '.gitignore', type: 'file' }
      ]
    };

    // Render file tree
    function renderFileTree() {
      // Load saved expansion state before rendering
      loadFileTreeState();

      const container = document.getElementById('file-tree');
      // Render children of root folder directly (don't show root)
      let html = '';
      if (fileTreeData.children) {
        fileTreeData.children.forEach(child => {
          html += renderTreeNode(child, 0);
        });
      }
      container.innerHTML = html;
      attachTreeListeners();
    }

    function renderTreeNode(node, depth) {
      const isFolder = node.type === 'folder';
      const hasChildren = isFolder && node.children && node.children.length > 0;
      const toggleIcon = hasChildren ? (node.expanded ? '&#9660;' : '&#9654;') : '';
      const icon = isFolder ? '&#128193;' : '&#128196;';
      const expandedClass = node.expanded ? 'expanded' : '';

      let html = `
        <div class="tree-item" data-depth="${depth}" data-type="${node.type}" data-name="${node.name}">
          <div class="tree-item-row">
            <span class="tree-toggle">${toggleIcon}</span>
            <span class="tree-icon">${icon}</span>
            <span class="tree-label">${node.name}</span>
          </div>
      `;

      if (hasChildren) {
        html += `<div class="tree-children ${expandedClass}">`;
        node.children.forEach(child => {
          html += renderTreeNode(child, depth + 1);
        });
        html += '</div>';
      }

      html += '</div>';
      return html;
    }

    function attachTreeListeners() {
      document.querySelectorAll('.tree-item-row').forEach(row => {
        row.addEventListener('click', (e) => {
          e.stopPropagation();
          const item = row.closest('.tree-item');
          const type = item.dataset.type;
          const name = item.dataset.name;

          // Handle selection
          document.querySelectorAll('.tree-item-row.selected').forEach(el => {
            el.classList.remove('selected');
          });
          row.classList.add('selected');

          // Toggle folder expansion
          if (type === 'folder') {
            const children = item.querySelector('.tree-children');
            const toggle = row.querySelector('.tree-toggle');
            if (children) {
              const isExpanded = children.classList.toggle('expanded');
              toggle.innerHTML = isExpanded ? '&#9660;' : '&#9654;';
              // Update data model and save to localStorage
              updateNodeExpanded(fileTreeData, name, isExpanded);
              saveFileTreeState();
            }
          }
        });
      });
    }

    function updateNodeExpanded(node, name, expanded) {
      if (node.name === name) {
        node.expanded = expanded;
        return true;
      }
      if (node.children) {
        for (const child of node.children) {
          if (updateNodeExpanded(child, name, expanded)) return true;
        }
      }
      return false;
    }

    // Save file tree expansion state to localStorage
    const FILE_TREE_STATE_KEY = 'marketbuffer_filetree_state';

    function saveFileTreeState() {
      const state = {};
      collectExpansionState(fileTreeData, state);
      localStorage.setItem(FILE_TREE_STATE_KEY, JSON.stringify(state));
    }

    function collectExpansionState(node, state) {
      if (node.type === 'folder') {
        state[node.name] = node.expanded || false;
      }
      if (node.children) {
        node.children.forEach(child => collectExpansionState(child, state));
      }
    }

    function loadFileTreeState() {
      const saved = localStorage.getItem(FILE_TREE_STATE_KEY);
      if (saved) {
        try {
          const state = JSON.parse(saved);
          applyExpansionState(fileTreeData, state);
        } catch (e) {
          console.error('Failed to load file tree state:', e);
        }
      }
    }

    function applyExpansionState(node, state) {
      if (node.type === 'folder' && state.hasOwnProperty(node.name)) {
        node.expanded = state[node.name];
      }
      if (node.children) {
        node.children.forEach(child => applyExpansionState(child, state));
      }
    }

    // Initial windows configuration
    const initialWindows = [
      {
        id: 'tabbed-main',
        title: 'Main',
        tabbed: true,
        draggable: false,
        closeable: true,
        zIndex: 50,
        top: 20,
        left: 20,
        right: 20,
        bottom: 20,
        tabs: [
          { id: 'tab-1', name: 'Tab 1', activePane: 'pane-1', panes: { id: 'pane-1', title: 'Pane 1', content: `
            <blockquote cite="" class="playground ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="editor-pane-1">
              <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
              <div class="ðŸ’ª">
                <div class="wb-gutter"></div>
                <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
              </div>
              <div class="ðŸ’ª wb-status ðŸ¦ ">
                <div class="wb-status-left ðŸ’ª">
                  <span class="wb-linecount"></span>
                </div>
                <div class="wb-status-right ðŸ’ª">
                  <span class="wb-coordinate"></span>
                  <span>|</span>
                  <span class="wb-indentation"></span>
                </div>
              </div>
            </blockquote>
          ` } }
        ],
        contextMenu: [
          { label: 'Split Vertical', action: 'split-vertical' },
          { label: 'Split Horizontal', action: 'split-horizontal' },
          { label: 'Close Pane', action: 'close-pane' },
          { label: 'Close', action: 'close' }
        ]
      },
      {
        id: 'finder',
        title: 'Marketbuffer HD',
        draggable: false,
        closeable: true,
        zIndex: 100,
        top: 80,
        right: 20,
        width: 400,
        contextMenu: [
          { label: 'Close', action: 'close' }
        ],
        content: `
          <div class="finder-content">
            <div class="finder-item">
              <div class="folder-icon"></div>
              <span class="finder-label">System</span>
            </div>
            <div class="finder-item">
              <div class="folder-icon"></div>
              <span class="finder-label">Applications</span>
            </div>
            <div class="finder-item">
              <div class="folder-icon"></div>
              <span class="finder-label">Documents</span>
            </div>
            <div class="finder-item">
              <div class="folder-icon"></div>
              <span class="finder-label">Utilities</span>
            </div>
            <div class="finder-item">
              <div class="document-icon"></div>
              <span class="finder-label">ReadMe</span>
            </div>
            <div class="finder-item">
              <div class="document-icon"></div>
              <span class="finder-label">Notes.txt</span>
            </div>
          </div>
        `
      },
      {
        id: 'about',
        title: 'About This Marketbuffer',
        draggable: true,
        closeable: true,
        zIndex: 101,
        top: 250,
        right: 40,
        width: 340,
        contextMenu: [
          { label: 'Close', action: 'close' }
        ],
        content: `
          <div class="about-content">
            <div class="macket-icon">
              <div class="macket-screen"></div>
              <div class="macket-base"></div>
            </div>
            <div class="about-title">Marketbuffer System</div>
            <div class="about-text">
              System Software 7.0<br>
              &copy; Marketbuffer Computer, Inc. 2025-2026
            </div>
            <hr class="about-divider">
            <div class="about-text">
              Built-in Memory: 4,096K<br>
              Total Memory: 8,192K
            </div>
            <br>
            <button class="macket-button">OK</button>
          </div>
        `
      },
      {
        id: 'hypercard',
        title: 'HyperCard - Welcome Stack',
        draggable: true,
        closeable: true,
        zIndex: 102,
        top: 140,
        right: 440,
        width: 360,
        contextMenu: [
          { label: 'Close', action: 'close' }
        ],
        content: `
          <div class="hypercard-content">
            <div class="hypercard-card">
              <div class="hypercard-title">Welcome to HyperCard</div>
              <div class="hypercard-text">
                HyperCard is your gateway to creating interactive stacks of information.
              </div>
              <div class="hypercard-text">
                Click the buttons below to explore:
              </div>
              <div style="text-align: center; margin-top: 20px;">
                <button class="hypercard-button">Browse</button>
                <button class="hypercard-button">Create</button>
                <button class="hypercard-button">Learn</button>
              </div>
            </div>
            <div class="hypercard-nav">
              <button class="hypercard-nav-btn">&larr; Prev</button>
              <span class="hypercard-page">Card 1 of 3</span>
              <button class="hypercard-nav-btn">Next &rarr;</button>
            </div>
          </div>
        `
      }
    ];

    // Open windows list (copy from initial on load)
    let openWindows = [];

    // Active window ID
    let activeWindowId = null;

    // Focused pane ID
    let focusedPaneId = null;

    // Global panes registry - stores pane info and editor instances
    window.paneRegistry = {};

    // Dragging state
    let activeWindow = null;
    let offsetX = 0;
    let offsetY = 0;

    // LocalStorage key
    const STORAGE_KEY = 'marketbuffer_windows_state';

    // Save state to localStorage
    function saveState() {
      const state = openWindows.map(win => ({
        id: win.id,
        zIndex: win.zIndex,
        top: win.top,
        left: win.left,
        right: win.right,
        bottom: win.bottom,
        activeTab: win.activeTab,
        tabs: win.tabs
      }));
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    // Load state from localStorage
    function loadState() {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        try {
          const state = JSON.parse(saved);
          // Merge saved state with initial windows (to get non-serialized properties)
          openWindows = state.map(savedWin => {
            const initialWin = initialWindows.find(w => w.id === savedWin.id);
            if (initialWin) {
              return { ...initialWin, ...savedWin };
            }
            return null;
          }).filter(Boolean);
          return true;
        } catch (e) {
          console.error('Failed to load state:', e);
        }
      }
      return false;
    }

    // Initialize on page load
    function init() {
      // Render file tree in sidebar
      renderFileTree();

      // Try to load from localStorage, otherwise use initial windows
      if (!loadState()) {
        openWindows = initialWindows.map(win => ({ ...win }));
      }
      renderWindows();

      // Set initial active window to the one with highest zIndex
      if (openWindows.length > 0) {
        const topWindow = openWindows.reduce((a, b) => a.zIndex > b.zIndex ? a : b);
        activeWindowId = topWindow.id;
        updateActiveWindowMenu();
      }
    }

    // Render panes recursively
    let splitIdCounter = 0;
    function renderPanes(pane, isMultiple = false, parentSplitId = null) {
      if (pane.direction) {
        // Split pane - children are in multiple pane mode
        const splitId = `split-${splitIdCounter++}`;
        const dirClass = pane.direction === 'vertical' ? 'pane-split-vertical' : 'pane-split-horizontal';
        const childrenHtml = pane.children.map(child => renderPanes(child, true, splitId)).join('');
        return `<div class="pane-split ${dirClass}" data-split-id="${splitId}">${childrenHtml}</div>`;
      } else {
        // Leaf pane
        const multiClass = isMultiple ? 'pane-multi' : '';
        const focusedClass = isMultiple && pane.id === focusedPaneId ? 'focused' : '';
        const titleHtml = isMultiple && pane.title ? `<div class="pane-title">${pane.title}</div>` : '';
        const parentAttr = parentSplitId ? `data-parent-split="${parentSplitId}"` : '';
        return `<div class="pane ${multiClass} ${focusedClass}" data-pane-id="${pane.id}" ${parentAttr}>${titleHtml}<div class="pane-content">${pane.content || ''}</div></div>`;
      }
    }

    // Render all open windows
    function renderWindows() {
      const desktop = document.getElementById('desktop');
      desktop.innerHTML = '';

      openWindows.forEach((win, index) => {
        const windowEl = document.createElement('div');

        if (win.tabbed) {
          // Tabbed window - positioned relative to desktop container
          windowEl.className = 'tabbed-window';
          windowEl.id = 'tabbed-window';
          windowEl.dataset.windowId = win.id;
          windowEl.style.zIndex = win.zIndex;
          windowEl.style.top = win.top + 'px';
          windowEl.style.left = win.left + 'px';
          windowEl.style.right = win.right + 'px';
          windowEl.style.bottom = win.bottom + 'px';

          // Render tabs
          const activeTab = win.activeTab || 0;
          const tabsHtml = win.tabs.map((tab, i) => {
            const isFirst = i === 0 && win.closeable;
            const classes = `tabbed-window-tab ${i === activeTab ? 'active' : ''} ${isFirst ? 'first-tab-with-close' : ''}`;
            return `<div class="${classes}" data-tab-index="${i}">${tab.name}<span class="tab-close" data-tab-index="${i}">&times;</span></div>`;
          }).join('');

          // Close button for closeable tabbed windows
          const closeBoxHtml = win.closeable
            ? `<div class="close-box tabbed-close-box" data-window-id="${win.id}"></div>`
            : '';

          // Render panes for ALL tabs (hidden unless active)
          const allTabPanesHtml = win.tabs.map((tab, tabIdx) => {
            const panesHtml = tab.panes ? renderPanes(tab.panes) : '';
            const isActive = tabIdx === activeTab ? 'active' : '';
            return `<div class="tab-pane-container ${isActive}" data-tab-index="${tabIdx}">${panesHtml}</div>`;
          }).join('');

          windowEl.innerHTML = `
            <div class="tabbed-window-inner">
              <div class="tabbed-window-tabs" id="tabbed-tabs">
                ${closeBoxHtml}
                ${tabsHtml}
                <div class="tabbed-window-tab-add" id="add-tab">+</div>
              </div>
              <div class="tabbed-window-content" id="tabbed-content">
                ${allTabPanesHtml}
              </div>
            </div>
          `;
        } else {
          // Regular window - positioned relative to desktop container
          windowEl.className = `window ${win.draggable ? 'window-draggable' : ''}`;
          windowEl.dataset.windowId = win.id;
          windowEl.style.top = win.top + 'px';
          windowEl.style.right = win.right + 'px';
          windowEl.style.width = win.width + 'px';
          windowEl.style.zIndex = win.zIndex;

          const closeBoxHtml = win.closeable
            ? `<div class="close-box" data-window-id="${win.id}"></div>`
            : '';

          windowEl.innerHTML = `
            <div class="window-title-bar">
              ${closeBoxHtml}
              <span class="window-title">${win.title}</span>
            </div>
            ${win.content}
          `;
        }

        desktop.appendChild(windowEl);
      });

      attachEventListeners();
      setupTabbedWindowListeners();
      initializePaneEditors();
    }

    // Initialize editors for all panes after rendering
    function initializePaneEditors() {
      // Find all editor elements and initialize WarrenBuf
      document.querySelectorAll('[id^="editor-pane-"]').forEach(editorEl => {
        // Skip if already initialized (check data attribute on element)
        if (editorEl.dataset.wbInitialized) return;

        const paneId = editorEl.id.replace('editor-', '');
        if (typeof WarrenBuf !== 'undefined') {
          editorEl.dataset.wbInitialized = 'true';
          window.paneRegistry[paneId] = {
            id: paneId,
            editorId: editorEl.id,
            editor: new WarrenBuf(editorEl, {})
          };
        }
      });
    }

    // Re-render only the active tab's pane container (preserves other tabs' editors)
    function renderActiveTabPanes() {
      const tabbedWin = openWindows.find(w => w.tabbed);
      if (!tabbedWin) return;

      const activeTab = tabbedWin.activeTab || 0;
      const tab = tabbedWin.tabs[activeTab];
      if (!tab) return;

      const container = document.querySelector(`.tab-pane-container[data-tab-index="${activeTab}"]`);
      if (!container) return;

      // Re-render only this tab's panes
      splitIdCounter = 0;
      const panesHtml = tab.panes ? renderPanes(tab.panes) : '';
      container.innerHTML = panesHtml;

      // Re-attach pane click handlers for this container
      container.querySelectorAll('.pane').forEach(pane => {
        pane.addEventListener('click', (e) => {
          e.stopPropagation();
          const paneId = pane.dataset.paneId;
          focusPane(paneId);
        });
      });

      // Initialize any new editors
      initializePaneEditors();
    }

    // Attach event listeners after rendering
    function attachEventListeners() {
      // Close button handlers
      document.querySelectorAll('.close-box').forEach(closeBox => {
        closeBox.addEventListener('click', (e) => {
          const windowId = e.target.dataset.windowId;
          closeWindow(windowId);
        });
      });

      // Draggable window handlers
      document.querySelectorAll('.window-draggable .window-title-bar').forEach(titleBar => {
        titleBar.addEventListener('mousedown', (e) => {
          if (e.target.classList.contains('close-box')) return;

          activeWindow = titleBar.closest('.window');
          const rect = activeWindow.getBoundingClientRect();
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;

          // Bring window to front
          bringToFront(activeWindow);
        });
      });

      // Click to bring window to front (all windows, not just draggable)
      document.querySelectorAll('.window').forEach(win => {
        win.addEventListener('mousedown', () => {
          bringToFront(win);
        });
      });
    }

    // Close a window (only if closeable)
    function closeWindow(windowId) {
      const win = openWindows.find(w => w.id === windowId);
      if (win && !win.closeable) return; // Can't close non-closeable windows
      openWindows = openWindows.filter(win => win.id !== windowId);

      // Update active window if the closed window was active
      if (activeWindowId === windowId) {
        if (openWindows.length > 0) {
          const topWindow = openWindows.reduce((a, b) => a.zIndex > b.zIndex ? a : b);
          activeWindowId = topWindow.id;
        } else {
          activeWindowId = null;
        }
        updateActiveWindowMenu();
      }

      saveState();
      renderWindows();
    }

    // Bring window to front
    function bringToFront(windowEl) {
      const windowId = windowEl.dataset.windowId;

      // Update zIndex in openWindows array
      openWindows.forEach(w => {
        if (w.tabbed) {
          w.zIndex = 50;
        } else {
          w.zIndex = 100;
        }
      });
      const win = openWindows.find(w => w.id === windowId);
      if (win) win.zIndex = 200;

      // Update DOM
      document.querySelectorAll('.window').forEach(w => w.style.zIndex = 100);
      const tabbedWin = document.getElementById('tabbed-window');
      if (tabbedWin) tabbedWin.style.zIndex = 50;
      windowEl.style.zIndex = 200;

      // Set active window
      activeWindowId = windowId;
      updateActiveWindowMenu();

      saveState();
    }

    // Bring tabbed window to front
    function bringTabbedToFront() {
      // Update zIndex in openWindows array
      const tabbedWindow = openWindows.find(w => w.tabbed);
      openWindows.forEach(w => {
        if (w.tabbed) {
          w.zIndex = 200;
        } else {
          w.zIndex = 100;
        }
      });

      // Update DOM
      document.querySelectorAll('.window').forEach(w => w.style.zIndex = 100);
      const tabbedWin = document.getElementById('tabbed-window');
      if (tabbedWin) tabbedWin.style.zIndex = 200;

      // Set active window
      if (tabbedWindow) {
        activeWindowId = tabbedWindow.id;
        updateActiveWindowMenu();
      }

      saveState();
    }

    // Mouse move handler for dragging
    document.addEventListener('mousemove', (e) => {
      if (!activeWindow) return;

      const desktop = document.getElementById('desktop');
      const desktopRect = desktop.getBoundingClientRect();
      const windowWidth = activeWindow.offsetWidth;
      const windowHeight = activeWindow.offsetHeight;

      // Calculate position relative to desktop
      let top = e.clientY - desktopRect.top - offsetY;
      let right = desktopRect.right - e.clientX - (windowWidth - offsetX);

      // Constrain to desktop bounds (all four edges)
      const maxTop = desktopRect.height - windowHeight;
      const maxRight = desktopRect.width - windowWidth;

      top = Math.max(0, Math.min(top, maxTop));
      right = Math.max(0, Math.min(right, maxRight));

      activeWindow.style.top = top + 'px';
      activeWindow.style.right = right + 'px';

      // Update position in openWindows array
      const windowId = activeWindow.dataset.windowId;
      const win = openWindows.find(w => w.id === windowId);
      if (win) {
        win.top = top;
        win.right = right;
      }
    });

    document.addEventListener('mouseup', () => {
      if (activeWindow) {
        saveState();
      }
      activeWindow = null;
    });

    // Initialize
    init();

    // Tabbed window functions
    function switchTab(tabIndex) {
      const tabbedWin = openWindows.find(w => w.tabbed);
      if (tabbedWin) {
        tabbedWin.activeTab = tabIndex;
        // Restore focusedPaneId from the tab's activePane
        const tab = tabbedWin.tabs[tabIndex];
        if (tab && tab.activePane) {
          focusedPaneId = tab.activePane;
        } else if (tab && tab.panes) {
          // Default to first pane if no activePane set
          const firstLeaf = findFirstLeafPane(tab.panes);
          focusedPaneId = firstLeaf ? firstLeaf.id : null;
        }
        saveState();

        // Update tab UI without re-rendering (preserve editor state)
        document.querySelectorAll('.tabbed-window-tab').forEach(tabEl => {
          const idx = parseInt(tabEl.dataset.tabIndex);
          if (idx === tabIndex) {
            tabEl.classList.add('active');
          } else {
            tabEl.classList.remove('active');
          }
        });

        // Toggle pane container visibility
        document.querySelectorAll('.tab-pane-container').forEach(container => {
          const idx = parseInt(container.dataset.tabIndex);
          if (idx === tabIndex) {
            container.classList.add('active');
          } else {
            container.classList.remove('active');
          }
        });

        // Update pane focus styling
        document.querySelectorAll('.pane-multi').forEach(p => {
          if (p.dataset.paneId === focusedPaneId) {
            p.classList.add('focused');
          } else {
            p.classList.remove('focused');
          }
        });
      }
    }

    // Pane ID counter
    let paneIdCounter = 1;

    // Collect all pane IDs from a pane tree
    function collectPaneIds(pane, ids = []) {
      if (!pane) return ids;
      if (pane.direction) {
        // Split pane - recurse into children
        pane.children.forEach(child => collectPaneIds(child, ids));
      } else {
        // Leaf pane
        ids.push(pane.id);
      }
      return ids;
    }

    // Get all active pane IDs across all tabs and windows
    function getAllActivePaneIds() {
      const allIds = [];
      openWindows.forEach(win => {
        if (win.tabs) {
          win.tabs.forEach(tab => {
            if (tab.panes) {
              collectPaneIds(tab.panes, allIds);
            }
          });
        }
      });
      return allIds;
    }

    function generatePaneId() {
      const activeIds = getAllActivePaneIds();
      // Find an unused pane ID
      while (activeIds.includes(`pane-${paneIdCounter}`)) {
        paneIdCounter++;
      }
      return `pane-${paneIdCounter++}`;
    }

    // Show upgrade alert when pane limit is reached
    function showUpgradeAlert() {
      const overlay = document.createElement('div');
      overlay.className = 'alert-overlay';
      overlay.innerHTML = `
        <div class="alert-box">
          <div class="alert-title">Pane Limit Reached</div>
          <div class="alert-message">
            You cannot open more than 8 panes per tab on the free plan.
            Upgrade to Pro for unlimited panes and advanced features.
          </div>
          <div class="alert-buttons">
            <button class="alert-btn" id="alert-cancel">Cancel</button>
            <button class="alert-btn alert-btn-upgrade" id="alert-upgrade">Upgrade</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);

      document.getElementById('alert-cancel').addEventListener('click', () => {
        overlay.remove();
      });

      document.getElementById('alert-upgrade').addEventListener('click', () => {
        // Handle upgrade action
        overlay.remove();
      });

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.remove();
        }
      });
    }

    function addTab() {
      const tabbedWin = openWindows.find(w => w.tabbed);
      if (tabbedWin) {
        const newIndex = tabbedWin.tabs.length;
        const newPaneId = generatePaneId();
        tabbedWin.tabs.push({
          id: `tab-${newIndex + 1}`,
          name: `Tab ${newIndex + 1}`,
          activePane: newPaneId,
          panes: { id: newPaneId, title: `Pane ${paneIdCounter}`, content: generateEditorHtml(newPaneId) }
        });
        tabbedWin.activeTab = newIndex;
        focusedPaneId = newPaneId;
        saveState();
        renderWindows();
      }
    }

    function closeTab(tabIndex) {
      const tabbedWin = openWindows.find(w => w.tabbed);
      if (tabbedWin) {
        tabbedWin.tabs.splice(tabIndex, 1);

        // If no tabs left, close the window
        if (tabbedWin.tabs.length === 0) {
          openWindows = openWindows.filter(w => w.id !== tabbedWin.id);
        } else {
          // Adjust active tab if needed
          if (tabbedWin.activeTab >= tabbedWin.tabs.length) {
            tabbedWin.activeTab = tabbedWin.tabs.length - 1;
          } else if (tabbedWin.activeTab > tabIndex) {
            tabbedWin.activeTab--;
          }
        }
        saveState();
        renderWindows();
      }
    }

    // Setup tabbed window listeners
    function setupTabbedWindowListeners() {
      const tabbedWin = document.getElementById('tabbed-window');
      if (tabbedWin) {
        tabbedWin.addEventListener('mousedown', bringTabbedToFront);
      }

      // Tab click handlers
      document.querySelectorAll('.tabbed-window-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          // Don't switch tab if clicking on close button
          if (e.target.classList.contains('tab-close')) return;
          const tabIndex = parseInt(tab.dataset.tabIndex);
          switchTab(tabIndex);
        });
      });

      // Tab close button handlers
      document.querySelectorAll('.tab-close').forEach(closeBtn => {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const tabIndex = parseInt(closeBtn.dataset.tabIndex);
          closeTab(tabIndex);
        });
      });

      // Add tab button
      const addBtn = document.getElementById('add-tab');
      if (addBtn) {
        addBtn.addEventListener('click', addTab);
      }

      // Pane click handlers
      document.querySelectorAll('.pane').forEach(pane => {
        pane.addEventListener('click', (e) => {
          e.stopPropagation();
          const paneId = pane.dataset.paneId;
          focusPane(paneId);
        });
      });
    }

    function focusPane(paneId) {
      focusedPaneId = paneId;

      // Save to the current tab's activePane
      const tabbedWin = openWindows.find(w => w.tabbed);
      if (tabbedWin) {
        const activeTab = tabbedWin.activeTab || 0;
        const tab = tabbedWin.tabs[activeTab];
        if (tab) {
          tab.activePane = paneId;
          saveState();
        }
      }

      // Update UI without full re-render - only apply to multi-pane
      document.querySelectorAll('.pane-multi').forEach(p => {
        if (p.dataset.paneId === paneId) {
          p.classList.add('focused');
        } else {
          p.classList.remove('focused');
        }
      });
    }

    // Active window menu
    function updateActiveWindowMenu() {
      const menuItem = document.getElementById('active-window-menu');
      const win = openWindows.find(w => w.id === activeWindowId);
      if (win) {
        menuItem.textContent = win.title;
      } else {
        menuItem.textContent = '';
      }
    }

    function renderActiveWindowDropdown() {
      const dropdown = document.getElementById('active-window-dropdown');
      dropdown.innerHTML = '';

      const win = openWindows.find(w => w.id === activeWindowId);
      if (!win || !win.contextMenu) return;

      win.contextMenu.forEach(item => {
        const menuItem = document.createElement('div');
        menuItem.className = 'menu-dropdown-item';
        menuItem.textContent = item.label;
        menuItem.addEventListener('click', () => {
          highlightParentSplit(false);
          executeContextMenuAction(win.id, item.action);
          closeActiveWindowMenu();
        });

        // Add hover highlight for close-pane
        if (item.action === 'close-pane') {
          menuItem.addEventListener('mouseenter', () => {
            highlightParentSplit(true);
          });
          menuItem.addEventListener('mouseleave', () => {
            highlightParentSplit(false);
          });
        }

        dropdown.appendChild(menuItem);
      });
    }

    function executeContextMenuAction(windowId, action) {
      if (action === 'close') {
        closeWindow(windowId);
      } else if (action === 'split-vertical') {
        splitPane(windowId, 'vertical');
      } else if (action === 'split-horizontal') {
        splitPane(windowId, 'horizontal');
      } else if (action === 'close-pane') {
        closePane(windowId);
      }
    }

    // Find and replace a pane by ID in the pane tree
    function findAndReplacePaneById(pane, targetId, replacement) {
      if (!pane.direction) {
        // Leaf pane
        if (pane.id === targetId) {
          return { found: true, result: replacement };
        }
        return { found: false, result: pane };
      }

      // Split pane - search children
      let found = false;
      const newChildren = pane.children.map(child => {
        if (found) return child;
        const result = findAndReplacePaneById(child, targetId, replacement);
        if (result.found) {
          found = true;
          return result.result;
        }
        return result.result;
      });

      return { found, result: { ...pane, children: newChildren } };
    }

    // Generate editor HTML for a pane
    function generateEditorHtml(paneId) {
      return `
        <blockquote cite="" class="playground ðŸ’ª ðŸœ ðŸ¥· ðŸŒ• ðŸªœ wb no-select" tabindex="0" id="editor-${paneId}">
          <textarea class="wb-clipboard-bridge" aria-hidden="true"></textarea>
          <div class="ðŸ’ª">
            <div class="wb-gutter"></div>
            <div class="wb-lines ðŸŒ³ ðŸ¥·"></div>
          </div>
          <div class="ðŸ’ª wb-status ðŸ¦ ">
            <div class="wb-status-left ðŸ’ª">
              <span class="wb-linecount"></span>
            </div>
            <div class="wb-status-right ðŸ’ª">
              <span class="wb-coordinate"></span>
              <span>|</span>
              <span class="wb-indentation"></span>
            </div>
          </div>
        </blockquote>
      `;
    }

    // Split the focused pane (DOM-based to preserve existing editors)
    function splitPane(windowId, direction) {
      const win = openWindows.find(w => w.id === windowId);
      if (!win || !win.tabbed) return;

      const activeTab = win.activeTab || 0;
      const tab = win.tabs[activeTab];
      if (!tab || !tab.panes) return;

      // Check pane limit (8 per tab)
      const tabPanes = [];
      collectPaneIds(tab.panes, tabPanes);
      if (tabPanes.length >= 8) {
        showUpgradeAlert();
        return;
      }

      // If no pane is focused, focus the first leaf pane
      if (!focusedPaneId) {
        const firstLeaf = findFirstLeafPane(tab.panes);
        if (firstLeaf) focusedPaneId = firstLeaf.id;
      }

      if (!focusedPaneId) return;

      // Find the focused pane element in DOM
      const paneEl = document.querySelector(`.pane[data-pane-id="${focusedPaneId}"]`);
      if (!paneEl) return;

      // Find the focused pane data
      const focusedPane = findPaneById(tab.panes, focusedPaneId);
      if (!focusedPane) return;

      // Generate new pane
      const newPaneId = generatePaneId();
      const newPaneTitle = `Pane ${paneIdCounter}`;
      const newPane = { id: newPaneId, title: newPaneTitle, content: generateEditorHtml(newPaneId) };

      // Update data model
      const replacement = {
        direction: direction,
        children: [
          { ...focusedPane },
          newPane
        ]
      };
      const result = findAndReplacePaneById(tab.panes, focusedPaneId, replacement);
      tab.panes = result.result;

      // DOM manipulation - create split container
      const splitId = `split-${splitIdCounter++}`;
      const splitEl = document.createElement('div');
      splitEl.className = `pane-split pane-split-${direction}`;
      splitEl.dataset.splitId = splitId;

      // Check if we're going from single pane to multiple
      const wasMultiple = paneEl.classList.contains('pane-multi');

      // Insert split container before the pane
      paneEl.parentNode.insertBefore(splitEl, paneEl);

      // Move existing pane into split container
      splitEl.appendChild(paneEl);

      // Update existing pane to multi-pane style
      paneEl.classList.add('pane-multi');
      paneEl.dataset.parentSplit = splitId;
      if (!wasMultiple) {
        // Add title if it didn't have one
        const titleEl = document.createElement('div');
        titleEl.className = 'pane-title';
        titleEl.textContent = focusedPane.title || focusedPaneId;
        paneEl.insertBefore(titleEl, paneEl.firstChild);
      }
      paneEl.classList.remove('focused');

      // Create new pane element
      const newPaneEl = document.createElement('div');
      newPaneEl.className = 'pane pane-multi focused';
      newPaneEl.dataset.paneId = newPaneId;
      newPaneEl.dataset.parentSplit = splitId;
      newPaneEl.innerHTML = `<div class="pane-title">${newPaneTitle}</div><div class="pane-content">${generateEditorHtml(newPaneId)}</div>`;

      // Add click handler to new pane
      newPaneEl.addEventListener('click', (e) => {
        e.stopPropagation();
        focusPane(newPaneId);
      });

      // Append new pane to split container
      splitEl.appendChild(newPaneEl);

      // Focus the new pane
      focusedPaneId = newPaneId;
      tab.activePane = newPaneId;

      saveState();

      // Initialize editor for new pane only
      initializePaneEditors();
    }

    // Find a pane by ID
    function findPaneById(pane, id) {
      if (!pane.direction) {
        return pane.id === id ? pane : null;
      }
      for (const child of pane.children) {
        const found = findPaneById(child, id);
        if (found) return found;
      }
      return null;
    }

    // Find first leaf pane
    function findFirstLeafPane(pane) {
      if (!pane.direction) {
        return pane;
      }
      return findFirstLeafPane(pane.children[0]);
    }

    // Close the focused pane and collapse its parent split (DOM-based)
    function closePane(windowId) {
      const win = openWindows.find(w => w.id === windowId);
      if (!win || !win.tabbed) return;

      const activeTab = win.activeTab || 0;
      const tab = win.tabs[activeTab];
      if (!tab || !tab.panes) return;

      // Can't close if it's the only pane (no splits)
      if (!tab.panes.direction) return;

      if (!focusedPaneId) {
        const firstLeaf = findFirstLeafPane(tab.panes);
        if (firstLeaf) focusedPaneId = firstLeaf.id;
      }

      if (!focusedPaneId) return;

      // Find the pane element to close
      const paneEl = document.querySelector(`.pane[data-pane-id="${focusedPaneId}"]`);
      if (!paneEl) return;

      const parentSplitId = paneEl.dataset.parentSplit;
      if (!parentSplitId) return;

      const parentSplitEl = document.querySelector(`.pane-split[data-split-id="${parentSplitId}"]`);
      if (!parentSplitEl) return;

      // Find sibling (the element that will remain)
      let siblingEl = null;
      for (const child of parentSplitEl.children) {
        if (child !== paneEl) {
          siblingEl = child;
          break;
        }
      }
      if (!siblingEl) return;

      // Clean up the editor being closed
      if (window.paneRegistry[focusedPaneId]) {
        delete window.paneRegistry[focusedPaneId];
      }

      // Update data model
      const result = removePaneById(tab.panes, focusedPaneId);
      if (!result.removed) return;
      tab.panes = result.result;

      // DOM manipulation - replace parent split with sibling
      const grandparent = parentSplitEl.parentNode;

      // Check if we're going back to single pane (grandparent is tab-pane-container)
      const isGoingToSingle = grandparent.classList.contains('tab-pane-container') && !siblingEl.classList.contains('pane-split');

      if (isGoingToSingle && siblingEl.classList.contains('pane')) {
        // Remove multi-pane styling when going back to single pane
        siblingEl.classList.remove('pane-multi', 'focused');
        delete siblingEl.dataset.parentSplit;
        // Remove title
        const titleEl = siblingEl.querySelector('.pane-title');
        if (titleEl) titleEl.remove();
      }

      // Replace split with sibling
      grandparent.insertBefore(siblingEl, parentSplitEl);
      parentSplitEl.remove();

      // Focus the first remaining pane
      const firstLeaf = findFirstLeafPane(tab.panes);
      focusedPaneId = firstLeaf ? firstLeaf.id : null;
      tab.activePane = focusedPaneId;

      // Update focus styling
      document.querySelectorAll('.pane-multi').forEach(p => {
        if (p.dataset.paneId === focusedPaneId) {
          p.classList.add('focused');
        } else {
          p.classList.remove('focused');
        }
      });

      saveState();
    }

    function highlightParentSplit(show) {
      // Remove any existing highlights
      document.querySelectorAll('.parent-highlight').forEach(el => {
        el.classList.remove('parent-highlight');
      });
      document.querySelectorAll('.closing-highlight').forEach(el => {
        el.classList.remove('closing-highlight');
      });
      document.querySelectorAll('.sibling-highlight').forEach(el => {
        el.classList.remove('sibling-highlight');
      });

      if (show && focusedPaneId) {
        const paneEl = document.querySelector(`.pane[data-pane-id="${focusedPaneId}"]`);
        if (paneEl) {
          // Highlight active pane in red
          paneEl.classList.add('closing-highlight');

          const parentSplitId = paneEl.dataset.parentSplit;
          if (parentSplitId) {
            const parentEl = document.querySelector(`.pane-split[data-split-id="${parentSplitId}"]`);
            if (parentEl) {
              parentEl.classList.add('parent-highlight');

              // Find and highlight sibling pane in teal
              const siblingPanes = parentEl.querySelectorAll(`:scope > .pane[data-parent-split="${parentSplitId}"]`);
              siblingPanes.forEach(sibling => {
                if (sibling.dataset.paneId !== focusedPaneId) {
                  sibling.classList.add('sibling-highlight');
                }
              });

              // Also check for sibling splits (highlight their leaf panes)
              const siblingSplits = parentEl.querySelectorAll(`:scope > .pane-split`);
              siblingSplits.forEach(split => {
                const leafPanes = split.querySelectorAll('.pane');
                leafPanes.forEach(leaf => {
                  leaf.classList.add('sibling-highlight');
                });
              });
            }
          }
        }
      }
    }

    // Remove a pane by ID and collapse the parent split
    function removePaneById(pane, targetId) {
      if (!pane.direction) {
        // Leaf pane - can't remove from here
        return { removed: false, result: pane };
      }

      // Check if one of the children is the target
      const targetIndex = pane.children.findIndex(child =>
        !child.direction && child.id === targetId
      );

      if (targetIndex !== -1) {
        // Found the target - return the sibling
        const siblingIndex = targetIndex === 0 ? 1 : 0;
        return { removed: true, result: pane.children[siblingIndex] };
      }

      // Recursively search in children
      let removed = false;
      const newChildren = pane.children.map(child => {
        if (removed) return child;
        const result = removePaneById(child, targetId);
        if (result.removed) {
          removed = true;
          return result.result;
        }
        return result.result;
      });

      return { removed, result: { ...pane, children: newChildren } };
    }

    function toggleActiveWindowMenu() {
      const dropdown = document.getElementById('active-window-dropdown');
      const isOpen = dropdown.classList.contains('open');
      if (isOpen) {
        closeActiveWindowMenu();
      } else {
        renderActiveWindowDropdown();
        dropdown.classList.add('open');
      }
    }

    function closeActiveWindowMenu() {
      const dropdown = document.getElementById('active-window-dropdown');
      dropdown.classList.remove('open');
      highlightParentSplit(false);
    }

    // Applications menu
    function renderApplicationsMenu() {
      const dropdown = document.getElementById('applications-dropdown');
      dropdown.innerHTML = '';

      initialWindows.forEach(win => {
        const isOpen = openWindows.some(w => w.id === win.id);
        const item = document.createElement('div');
        item.className = `menu-dropdown-item ${isOpen ? 'checked' : ''}`;
        item.textContent = win.title;
        item.dataset.windowId = win.id;
        item.addEventListener('click', () => {
          openApplication(win.id);
          closeApplicationsMenu();
        });
        dropdown.appendChild(item);
      });
    }

    function openApplication(windowId) {
      const isOpen = openWindows.some(w => w.id === windowId);
      if (!isOpen) {
        const win = initialWindows.find(w => w.id === windowId);
        if (win) {
          // Reset all z-indexes
          openWindows.forEach(w => {
            w.zIndex = w.tabbed ? 50 : 100;
          });
          // Add new window with highest z-index
          const newWin = { ...win, zIndex: 200 };
          openWindows.push(newWin);
          // Set as active window
          activeWindowId = windowId;
          saveState();
          renderWindows();
          updateActiveWindowMenu();
        }
      }
    }

    function toggleApplicationsMenu() {
      const dropdown = document.getElementById('applications-dropdown');
      const isOpen = dropdown.classList.contains('open');
      if (isOpen) {
        closeApplicationsMenu();
      } else {
        renderApplicationsMenu();
        dropdown.classList.add('open');
      }
    }

    function closeApplicationsMenu() {
      const dropdown = document.getElementById('applications-dropdown');
      dropdown.classList.remove('open');
    }

    // Active window menu event listeners
    document.getElementById('active-window-menu').addEventListener('click', (e) => {
      e.stopPropagation();
      closeApplicationsMenu();
      toggleActiveWindowMenu();
    });

    // Applications menu event listeners
    document.getElementById('applications-menu').addEventListener('click', (e) => {
      e.stopPropagation();
      closeActiveWindowMenu();
      toggleApplicationsMenu();
    });

    document.addEventListener('click', () => {
      closeApplicationsMenu();
      closeActiveWindowMenu();
    });
  </script>
</body>
</html>
